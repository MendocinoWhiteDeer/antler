* antler

License: LGPL 3.0

A convenience library for Vulkan graphics programming. Not ready for use.

To do a debug build ...

#+BEGIN_SRC shell
cmake -S . -B debug-build -DCMAKE_BUILD_TYPE=Debug
cd debug-build
make
#+END_SRC

To do a release build ...

#+BEGIN_SRC shell
cmake -S . -B release-build
cd release-build
make
#+END_SRC

Make sure the working directory is the same as the binary directory when running samples.
Otherwise, the sample program will have trouble finding the needed resources to run properly.
The different sample programs are documented in this README file.

** Learning Resources

https://docs.vulkan.org/guide/latest/vulkan_spec.html

Real‐Time Rendering, 4th Edition by Tomas Akenine-Möller, Eric Haines, Naty Hoffman, Angelo Pesce, Michał Iwanicki, and Sébastien Hillaire

https://saschawillems.de

https://www.songho.ca

https://vkguide.dev

https://vulkan-tutorial.com/

** Dependencies
*** Submodules

GLFW: https://github.com/glfw/glfw

*** System installation

Vulkan

** Samples
*** add-vectors

After providing a seed, this sample uses a compute shader to add two random vectors of a fixed size.

*** conway-game-of-life

The user provides grid dimensions and a seed for the initial random active and dead states of cells in a grid.
Then the grid evolves according to the rules of John Conway's Game of Life. At each time step,

1. Any active cell with one or fewer active cell neighbors deactivates.
2. Any active cell with four or more active cell neighbors deactivates.
3. Any dead cell with three total active cell neighbors activates.

If the cell is active it is rendered as white.

**** References

Gardner, M. (1970). MATHEMATICAL GAMES. Scientific American, 223(4), 120–123. http://www.jstor.org/stable/24927642

*** rotating-cube

Simulates a uniform density cube rotating about its center of mass.
The cube grows and shrinks in size periodically at a fixed mass, producing a torque which changes its rotational velocity.
Updates occur with a fixed time step, then we interpolate between update frames for each render frame.
Basic diffuse lighting is used to give the cube some dimensionality.
The light source is a directional light parallel to the displacement between the camera and the cube.

For unit mass m and side length s(t) as a function of time in seconds t,
the rotational inertia tensor of a cube is simply a scaling of the identity matrix:

I(t) = (m/6) * s(t)^2 * diag(1, 1, 1)

Let omega(t) represent the rotational velocity psuedovector.
For fixed mass, conservation of rotational momentum demands:

omega(t) * s(t)^2 = omega(0) * s(0)^2

Now we need to integrate omega(t). s(t) must be a periodic function strictly greater than zero.
If s(t) were zero, conservation of rotational momentum would be violated.

To avoid numerical integration, lets choose something nice and easy.

s(t) = [1 + 0.5 * sin((2 * pi * t) / period)]^(-1/2), so s(0) = 1
omega(t) = (1 + 0.5 * sin((2 * pi * t) / period)) * omega(0)

The period is not the period of the cube's rotation, but the period of s(t).
We can now integrate omega(t), a function which we call theta(t).

theta(t) = (t - (period / (4 * pi)) * cos((2 * pi * t) / period) + C) * omega(0), where C is some constant

theta(0) = 0 implies
theta(t) = (t + (period / (4 * pi)) * (1 - cos((2 * pi * t) / period))) * omega(0)

When programming this, we can convert theta into an axis-angle representation.
The axis stays fixed over time, equal to the normalization of omega(0) while
the angle is (t + (period / (4 * pi)) * (1 - cos((2 * pi * t) / period))) multipled by the norm of omega(0).
So one can calculate theta(t) as a quaternion by providing an initial angular speed v0 and an axis.

It is worth mentioning that rather than approximating angle(t) with a time step and an integration technique,
we are plugging in an ever-increasing value for t.
This means that t loses decimal precision as the simulation runs.
The simulation likely won't run so long, but I'll consider this a fun little extra feature.

Restrict t to the interval [0, period). If n is some natural number, then

angle(t + n * period) - angle(n * period) = (t - (period / (4 * pi)) *  cos((2 * pi * t) / period)) * v0
, where angle(n * period) = n * period * v0.
s(t + n * period) = [1 + 0.5 * sin((2 * pi * t) / period)]^(-1/2)

Consider a new parameter alpha, which is initialized to zero. The update procedure is

1. On update, if t leaves the interval [0, period), shift it by subtracting the period n times until it is back in the interval.
   Then update alpha by adding  n * period * omega(0). Shift alpha in steps of 2 * pi until it is in the interval [0, 2 * pi).
2. Store the side-length from the previous frame.
   Set s = [1 + 0.5 * sin((2 * pi * t) / period)]^(-1/2)
3. Store the angle from the previous frame.
   Set angle = alpha + (t - (period / (4 * pi)) *  cos((2 * pi * t) / period)) * omega(0).
   Naive, individual shifts will cause problems when interpolating between the previous and current update frames.
   The angle of the current and previous update frames both need to be shifted the same amount.

*** hello-quad

A basic quad. Unlke hello-triangle, it uses vertex and index buffers.

*** hello-triangle

A basic program to display a colored triangle.
There are no vertex buffers; the vertex data is hardcoded into the vertex shader.
